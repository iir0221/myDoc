# 垃圾收集与内存分配

程序计数器，虚拟机栈，本地方法栈随着线程而生，随线程而灭，方法结束或者线程结束，内存自然就跟着回收了。栈帧分配多少内存基本在类结构确定下来时就已知。因此这几个区域不需要过多考虑垃圾回收与内存分配策略问题，。

**垃圾回收与内存分配策略，主要是针对堆和方法区而言。**

## 如何确定一个对象已经死亡

* 引用计数法

* 可达性分析算法（jvm使用这种算法）


## 回收方法区（永久代）
jvm不要求回收方法区


## TLAB

  堆是JVM中所有线程共享的，因此在其上进行对象内存的分配均需要进行加锁，这也导致了new对象的开销是比较大的
  鉴于上面的原因，Sun Hotspot JVM为了提升对象内存分配的效率，对于所创建的线程都会分配一块独立的空间（Eden上），这块空间又称为TLAB（Thread Local Allocation Buffer），其大小由JVM根据运行的情况计算而得（默认Eden的1%），在TLAB上分配对象时不需要加锁，因此JVM在给线程的对象分配内存时会尽量的在TLAB上分配，在这种情况下JVM中分配对象内存的性能和C基本是一样高效的，但如果对象过大的话则仍然是直接使用堆空间分配
  TLAB仅作用于新生代的Eden Space，因此在编写Java程序时，通常多个小的对象比大的对象分配起来更加高效，但这种方法同时也带来了两个问题，一是空间的浪费，二是对象内存的回收上仍然没法做到像Stack那么高效，同时也会增加回收时的资源的消耗，可通过在启动参数上增加-XX:+PrintTLAB来查看TLAB这块的使用情况。

