# 树
* 一棵树有N个节点，则存在N-1条边
    * 因为每条边都将某个节点连接到它的父亲，而除去跟节点外每一个节点都有一个父亲。

* 树叶：没有儿子的节点
* 深度：根到节点n的唯一路径的长，根的深度为0
* 高：节点n到一片树叶的最长路径的长，树叶高为0，一棵树的高等于根的高
* 树的实现
```java
class TreeNode {
    Object element;
    TreeNode firstChild;
    TreeNode nextSibling;
}
```
# 二叉树
* 遍历
    * 前序
    * 中序
    * 后序
    * 层次

# 二叉查找树
对于树中的每个节点X，它的左子树的所有项的值小于X。它的右子树中所有的项的值大于X。

## contains
* [尾递归](https://www.zhihu.com/question/20761771)

## findMin findMax
* Min:只要有左儿子就向左进行
* Max:只要有右儿子就向右进行

## insert
假设同一个val只在二叉查找树中出现一次，则insert同contains基本相似，只是在x插入到遍历路径的最后一个节点上

## remove

* 删除节点为叶子节点，则直接删除
* 删除节点有一个子节点，其父亲节点调整自己的链接，绕过该节点实现删除
* 删除节点有两个子节点，
    * 首先使用该节点右子树的最小数据代替该节点的数据
    * 然后递归地删除那个节点，因为右子树的最小数据不可能有左儿子，所以第二次删除容易的多


* 懒惰删除：只是标记删除，而不是真的删除

# B树(B-tree)与B+树
磁盘读取数据是以盘块(block)为基本单位的。位于同一盘块中的所有数据都能被一次性全部读取出来。而磁盘IO代价主要花费在查找时间Ts上。因此我们应该尽量将相关信息存放在同一盘块，同一磁道中。或者至少放在同一柱面或相邻柱面上，以求在读/写信息时尽量减少磁头来回移动的次数，避免过多的查找时间Ts。

所以，在大规模数据存储方面，大量数据存储在外存磁盘中，而在外存磁盘中读取/写入块(block)中某数据时，首先需要定位到磁盘中的某块，如何有效地查找磁盘中的数据，需要一种合理高效的外存数据结构，就是下面所要重点阐述的B-tree结构，以及相关的变种结构：B+-tree结构和B*-tree结构。